package org.orienteer.transponder;

import static org.orienteer.transponder.CommonUtils.*;
import static net.bytebuddy.matcher.ElementMatchers.*;

import java.io.Serializable;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.function.Supplier;

import org.orienteer.transponder.annotation.EntityIndex;
import org.orienteer.transponder.annotation.EntityProperty;
import org.orienteer.transponder.annotation.EntityPropertyIndex;
import org.orienteer.transponder.annotation.EntityType;
import org.orienteer.transponder.mutator.StackedMutator;
import org.orienteer.transponder.polyglot.DefaultPolyglot;

import com.google.common.base.Objects;
import com.google.common.base.Strings;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.NamingStrategy;
import net.bytebuddy.TypeCache;
import net.bytebuddy.description.annotation.AnnotationList;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.description.type.TypeList;
import net.bytebuddy.description.type.TypeDescription.Generic;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
import net.bytebuddy.jar.asm.Opcodes;
import net.bytebuddy.utility.RandomString;

/**
 * Main class for all API provided by this library. Typical use-cases/flows are the following:
 * <ul>
 * 	<li>Create Transponder instance as <code>new Transponder(new CustomDriver(...))</code>.
 * 		Driver provides access to a required data-source.</li>
 *  <li>If needed, define a data-model in the data-source with the aid of {@link #define(Class...)}</li>
 *  <li>Obtain a Data-Access-Object for accesing actual data. Please check {@link #dao(Class, Class...)}</li>
 *  <li>Transponder can wrap ({@link #provide(Object, Class, Class...)}, {@link #wrap(Object, Type)}) 
 *  data-source specific entities and unwrap ({@link #unwrap(Object)}) previously wrapped entities back into
 *  data-source specific entities</li>
 * </ul>
 * Internally Transponder uses <a href="https://bytebuddy.net/">ByteBuddy</a> to generate wrapping classes
 * over data-source specific classes. For example, for OrientDB Transponder generate wrapping classes according
 * to specified interfaces over ODocumentWrapper, implementing all required getters, setters, lookup methods, query and etc.
 */
public class Transponder {
	
	private static final TypeCache<Integer> DAO_CACHE = new TypeCache<Integer>(TypeCache.Sort.SOFT);
	
	private final IDriver driver;
	private IPolyglot polyglot = new DefaultPolyglot();
	
	/**
	 * Interface-marker for all wrappers generated by Transponder: for wrappers/entities and for DAO
	 */
	public static interface ITransponderHolder {
		//CHECKSTYLE IGNORE MethodName FOR NEXT 8 LINES
		/**
		 * @return associated {@link Transponder} for the instance
		 */
		public Transponder get$transponder();
		/**
		 * @param transponder transponder to associate instance with
		 */
		public void set$transponder(Transponder transponder);
	}
	
	/**
	 * Interface-marker to designate specifically wrappers/entities
	 */
	public static interface ITransponderEntity extends ITransponderHolder{
		
	}
	
	/**
	 * Create a {@link Transponder} instance for the specified driver
	 * @param driver transponder driver to be used
	 */
	public Transponder(IDriver driver) {
		this.driver = driver;
	}
	
	/**
	 * @return driver
	 */
	public IDriver getDriver() {
		return driver;
	}
	
	/**
	 * Create new wrapped entity
	 * @param <T> type of a main class/interface
	 * @param mainClass type of a main class/interface
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return newly created wrapped entity. Commonly it's not yet persisted.
	 */
	public <T> T create(Class<T> mainClass, Class<?>... additionalInterfaces) {
		EntityType entityType = mainClass.getAnnotation(EntityType.class);
		if(entityType==null)
			throw new IllegalArgumentException("Main class '"+mainClass.getName()+
								"' should be annotated by @"+EntityType.class.getSimpleName());
		return create(mainClass, entityType.value(), additionalInterfaces);
	}
	
	/**
	 * Create new wrapped entity
	 * @param <T> type of a main class/interface
	 * @param mainClass type of a main class/interface
	 * @param typeName name of a type in a data-source for which new entity should be created
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return newly created wrapped entity. Commonly it's not yet persisted.
	 */
	public <T> T create(Class<T> mainClass, String typeName, Class<?>... additionalInterfaces) {
		if(typeName==null) throw new NullPointerException("TypeName for Transponder.create(...) should not be null");
		Class<T> proxyClass = getProxyClass(driver.getDefaultEntityBaseClass(), mainClass, true, additionalInterfaces);
		return setTransponder(driver.newEntityInstance(proxyClass, typeName));
	}
	
	/**
	 * Provide wrapper for the seed object
	 * @param <T> type of wrapper
	 * @param seed entity to be wrapped
	 * @return wrapped entity
	 */
	public <T> T provide(Object seed) {
		Class<T> mainClass = (Class<T>)driver.getEntityMainClass(seed);
		return provide(seed, mainClass);
	}
	
	/**
	 * Provide wrapper for the seed object
	 * @param <T> type of wrapper
	 * @param seed entity to be wrapped
	 * @param mainClass type of a wrapper
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return wrapped entity
	 */
	public <T> T provide(Object seed, Class<T> mainClass, Class<?>... additionalInterfaces) {
		Class<T> expectedMainClass = (Class<T>)driver.getEntityMainClass(seed);
		if(expectedMainClass!=null && mainClass.isAssignableFrom(expectedMainClass)) mainClass = expectedMainClass;
		if(mainClass.isInstance(seed)) {
			boolean compatible = true;
			if(additionalInterfaces!=null) {
				for (Class<?> addon : additionalInterfaces) {
					if(!addon.isInstance(seed)) {
						compatible = false;
						break;
					}
				}
			}
			if(compatible) return (T) seed;
		}
		Class<T> proxyClass = getProxyClass(driver.getDefaultEntityBaseClass(), mainClass, true, additionalInterfaces);
		return setTransponder(driver.wrapEntityInstance(proxyClass, seed));
	}
	
	/**
	 * Wrap if needed provided seed object
	 * @param <T> type of wrapper
	 * @param seed object, or collection of seed objects to be wrapped
	 * @param targetType target type of the result
	 * @return wrapped object
	 */
	public <T> T wrap(Object seed, Type targetType) {
		if(seed==null) return null;
		Class<?> requiredClass = CommonUtils.typeToMasterClass(targetType);
		if(seed instanceof ITransponderHolder) {
			return (T) seed;
		} else if(driver.isSeed(seed)) {
			return (T) provide(seed, requiredClass);
		} else if(seed instanceof Iterable) {
			Iterator<?> it = ((Iterable<?>)seed).iterator(); 
			if(!it.hasNext()) return (T) newInstance(requiredClass);
			Object probe;
			do {
				probe = it.next();
			} while(it.hasNext() && probe == null);
			if(driver.isSeed(probe)) {
				return wrapIterable((Iterable<?>)seed, targetType);
			} else if(Collection.class.isAssignableFrom(requiredClass)) {
				Collection<Object> collection = (Collection<Object>)newInstance(requiredClass);
				if(probe!=null) collection.addAll((Collection<Object>)seed);
				else {
					Class<?> elementClass = typeToRequiredClass(targetType);
					if(elementClass==null 
							|| elementClass.getAnnotation(EntityType.class)==null) collection.addAll((Collection<Object>)seed);
				}
				return (T)collection;
			}
			else throw new IllegalStateException("Can't prepare required return class: "+requiredClass +" from "+seed.getClass());
		} else if(seed instanceof Map) {
			
			Map<?, ?> map = (Map<?, ?>)seed;
			if(map.size()==0) return (T) seed;
			Iterator<?> it = map.values().iterator();
			Object probe;
			do {
				probe = it.next();
			} while(it.hasNext() && probe == null);
			if(driver.isSeed(probe)) {
				return wrapMap((Map<?, ?>)map, targetType);
			} else if(Map.class.isAssignableFrom(requiredClass)) {
				return (T)map;
			}
			else throw new IllegalStateException("Can't prepare required return class: "+requiredClass +" from "+seed.getClass());
		} else if(requiredClass.isInstance(seed)) return (T)seed;
		return null;
	}
	
	protected <T> T wrapIterable(Iterable<?> seeds, Type targetType) {
		if(seeds==null) return null;
		Class<?> requiredSubType = typeToRequiredClass(targetType);
		
		Iterable<?> ret;
		if(driver.isSeedClass(requiredSubType)) {
			ret = seeds;
		}
		else {
			List<Object> inner = new ArrayList<>();
			for (Object seed : seeds) {
				inner.add(provide(seed, requiredSubType));
			}
			ret = inner;
		}
		
		Class<?> masterClass = CommonUtils.typeToMasterClass(targetType);
		if(masterClass.isAssignableFrom(ret.getClass())) return (T)ret;
		else if(Collection.class.isAssignableFrom(masterClass)) {
			Collection<Object> instance = (Collection<Object>)newInstance(masterClass);
			instance.addAll((Collection<Object>)ret);
			return (T) instance;
		}
		else throw new IllegalStateException("Can't prepare required return type: "+targetType);
	}
	
	protected <T> T wrapMap(Map<?, ?> map, Type targetType) {
		if(map==null) return null;
		Class<?> requiredSubType = typeToRequiredClass(targetType);
		
		Map<?, ?> ret;
		if(driver.isSeedClass(requiredSubType)) {
			ret = map;
		}
		else {
			Map<Object, Object> inner = new HashMap<>();
			for (Map.Entry<?, ?> entry : map.entrySet()) {
				inner.put(entry.getKey(), provide(entry.getValue(), requiredSubType));
			}
			ret = inner;
		}
		
		if(CommonUtils.typeToMasterClass(targetType).isAssignableFrom(Map.class)) return (T) ret;
		else throw new IllegalStateException("Can't prepare required return type: "+targetType);
	}
	
	/**
	 * Unwrap provided object. If it's not a wrapper - return as is
	 * @param wrapper object to be unwrapped
	 * @return seed object or original object if nothing to unwrap
	 */
	public static Object unwrap(Object wrapper) {
		if(wrapper==null) return null;
		if(isSimpleType(wrapper)) return wrapper;
		else if (wrapper instanceof ITransponderHolder) {
			if(wrapper instanceof ITransponderEntity) {
				Transponder otherTransponder = ((ITransponderHolder)wrapper).get$transponder();
				return otherTransponder.getDriver().toSeed(wrapper);
			} else return wrapper;
		}
		else if (wrapper instanceof Collection<?>) {
			Collection<?> col = (Collection<?>)wrapper;
			List<Object> ret = new ArrayList<>(col.size());
			for (Object object : col) ret.add(unwrap(object));
			return ret;
		} else if (wrapper instanceof Map) {
			Map<?, ?> map = (Map<?, ?>)wrapper;
			Map<Object, Object> ret = new HashMap<Object, Object>(map.size());
			for (Map.Entry<?, ?> entry : map.entrySet()) ret.put(entry.getKey(), unwrap(entry.getValue()));
			return ret;
		} else if (wrapper.getClass().isArray()) {
			Object[] array = (Object[])wrapper;
			List<Object> ret = new ArrayList<>(array.length);
			for (Object object : array) ret.add(unwrap(object));
			return ret;
		} else if(wrapper instanceof Serializable) {
			return wrapper;
		} else throw new IllegalStateException("Type "+wrapper.getClass()+" can't be cast to use in DB");
	}
	
	/**
	 * Rewrap provided wrapper into new mainClass with optional additional interfaces
	 * @param <T> type of wrapper
	 * @param wrapper wrapped object to be rewrapped
	 * @param mainClass new main class to rewrap into
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return rewrapped object
	 */
	public static <T> T rewrap(Object wrapper, Class<T> mainClass, Class<?>... additionalInterfaces) {
		Transponder transponder = getTransponder(wrapper);
		if(wrapper instanceof ITransponderEntity) {
			return transponder.provide(transponder.getDriver().toSeed(wrapper), mainClass, additionalInterfaces);
		} else {
			return transponder.dao(mainClass, additionalInterfaces);
		}
	}
	
	/**
	 * Upgrade provided wrapper by addition additional interfaces
	 * @param <T> type of wrapper
	 * @param wrapper wrapped object to be upgraded
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return new wrapped object instance, but with the same seed object
	 */
	public static <T> T upgrade(T wrapper, Class<?>... additionalInterfaces) {
		if(additionalInterfaces==null || additionalInterfaces.length==0) return wrapper;
		List<Class<?>> toAdd = new ArrayList<>();
		for (Class<?> interf : additionalInterfaces) {
			if(!interf.isInstance(wrapper)) toAdd.add(interf);
		}
		if(toAdd.isEmpty()) return wrapper;
		Class<?>[] originalIntefaces = wrapper.getClass().getInterfaces();
		toAdd.addAll(0, Arrays.asList(originalIntefaces));
		toAdd.remove(ITransponderEntity.class);
		toAdd.remove(ITransponderHolder.class);
		Class<?> mainClass = toAdd.get(0);
		toAdd.remove(0);
		Class<?>[] additional = toAdd.toArray(new Class<?>[toAdd.size()]);
		return (T)rewrap(wrapper, mainClass, additional);
	}
	
	@SuppressWarnings("unchecked")
	protected <T> Class<T> getProxyClass(Class<?> baseClass, Class<T> mainClass, boolean entity, final Class<?>... additionalInterfaces) {
		Integer hash =   Arrays.hashCode(additionalInterfaces);
		hash = Objects.hashCode(driver.getCacheKey(), mainClass, hash);
		return (Class<T>) DAO_CACHE.findOrInsert(mainClass.getClassLoader(), hash, () -> {
			ByteBuddy byteBuddy = new ByteBuddy();
			DynamicType.Builder<?> builder;
			StringBuilder nameBuilder = new StringBuilder("transponder.").append(driver.getDialect()).append(".");
			List<Class<?>> classesToImplement = new ArrayList<>();
			
			if(!mainClass.isInterface()) {
				if(!baseClass.isAssignableFrom(mainClass))
					throw new IllegalArgumentException("Main class "+mainClass.getName()+" should be inherited from "+baseClass.getName() +" or be an interface");
				builder = byteBuddy.subclass(mainClass);
			} else {
				builder = byteBuddy.subclass(baseClass);
				classesToImplement.add(mainClass);
			}
			EntityType entityType = mainClass.getAnnotation(EntityType.class);
			if(entityType!=null) nameBuilder.append(entityType.value());
			else if(!entity) nameBuilder.append("dao.").append(mainClass.getSimpleName());
			else nameBuilder.append("other.").append(mainClass.getSimpleName());
			
			classesToImplement.add(entity?ITransponderEntity.class:ITransponderHolder.class);
			if(additionalInterfaces!=null && additionalInterfaces.length>0) {
				classesToImplement.addAll(Arrays.asList(additionalInterfaces));
				nameBuilder.append("$").append(RANDOM_STRING.nextString());
			}
			builder = builder.name(nameBuilder.toString());
			builder = builder.implement(classesToImplement);
			BuilderScheduler scheduler = new BuilderScheduler();
			builder = StackedMutator.resolveRootMutator(entity).mutate(this, builder, scheduler);
			
			IMutator driverMutator = driver.getMutator();
			if(driverMutator!=null) builder = driverMutator.mutate(this, builder, scheduler);
			builder = scheduler.apply(builder);
			
			builder = builder.defineField("$transponder", Transponder.class, Opcodes.ACC_PRIVATE)
									.method(isDeclaredBy(ITransponderHolder.class)
												.and(isAbstract()))
									.intercept(FieldAccessor.ofField("$transponder"));
			return builder.make()
					  .load(mainClass.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
					  .getLoaded();
		});
	}
	
	/**
	 * Provides Data Access Object for corresponding classes/interfaces
	 * @param <T> type of DAO
	 * @param mainClass type of DAO
	 * @param additionalInterfaces additional interfaces for the generated class
	 * @return instance of the generated DAO
	 */
	@SuppressWarnings("unchecked")
	public <T> T dao(Class<T> mainClass, final Class<?>... additionalInterfaces) {
		return setTransponder(driver.newDAOInstance(getProxyClass(Object.class, mainClass, false, additionalInterfaces)));
	}
	
	/**
	 * Define in the data-source corresponding schema (types, properties, indexes) for provided classes
	 * @param classes set of classes to be introspected in reflected in a data-source schema
	 * @return this transponder for chaining
	 */
	public Transponder define(Class<?>... classes) {
		DescribeContext ctx = new DescribeContext(this);
		define(Arrays.asList(classes), ctx);
		ctx.close(false);
		return this;
	}
	
	private Set<String> define(List<Class<?>> classes, DescribeContext ctx) {
		Set<String> types = new HashSet<String>();
		for (Class<?> clazz : classes) {
			String className = define(clazz, ctx);
			if(className!=null) types.add(className);
		}
		return types;
	}
	
	String define(Class<?> clazz, DescribeContext ctx) {
		if(clazz==null || !clazz.isInterface()) return null;	
		final EntityType type = clazz.getAnnotation(EntityType.class);
		if(type==null) return null;
		if(ctx.wasDescribed(clazz)) return ctx.getDefinedType(clazz);
//		else if(ctx.inStack(clazz)) return ctx.getTypeFromStack(clazz);
		ctx.entering(clazz, type.value());
		List<Class<?>> interfaces = Arrays.asList(clazz.getInterfaces());
		Set<String> superClasses = define(interfaces, ctx);
		superClasses.addAll(Arrays.asList(type.superTypes()));
		
		int currentOrder=type.orderOffset()-type.orderStep(); // Minus is needed to have first property with orderOffset
		
		List<Method> methods = listDeclaredMethods(clazz);
		
		for(Method method : methods) {
			if(method.isDefault() || Modifier.isStatic(method.getModifiers())) continue; //Ignore default methods
			String methodName = method.getName();
			Parameter[] params =  method.getParameters();
			String fieldNameCandidate = null;
			final Type fieldType;
			if(methodName.startsWith("set") && params.length==1) {
				fieldNameCandidate = decapitalize(methodName.substring(3));
				fieldType = params[0].getParameterizedType();
			} else if(methodName.startsWith("get") && params.length==0) {
				fieldNameCandidate = decapitalize(methodName.substring(3));
				fieldType = method.getGenericReturnType();
			} else if(methodName.startsWith("is") && params.length==0) {
				fieldNameCandidate = decapitalize(methodName.substring(2));
				fieldType = method.getGenericReturnType();
			} else continue;
			final EntityProperty property = method.getAnnotation(EntityProperty.class);
			if(property!=null && !Strings.isNullOrEmpty(property.value())) fieldNameCandidate = property.value();
			final boolean wasPreviouslyScheduled = ctx.isPropertyCreationScheduled(fieldNameCandidate);
			//Skip second+ attempt to create a property, except if @EntityProperty is present
			if(wasPreviouslyScheduled /*&& canSkipIfAlreadyScheduled(property)*/) continue;
			
			String linkedTypeCandidate = ctx.resolveOrDefineTypeClass(typeToMasterClass(fieldType), true);
			if(linkedTypeCandidate==null) linkedTypeCandidate = ctx.resolveOrDefineTypeClass(typeToRequiredClass(fieldType), true);
			if(linkedTypeCandidate==null && property!=null && !Strings.isNullOrEmpty(property.referencedType())) linkedTypeCandidate = property.referencedType();
			
			final String fieldName = fieldNameCandidate;
			final String linkedType = linkedTypeCandidate;
			final int order = property!=null && property.order()>=0 
								? property.order()
								: (currentOrder+=type.orderStep());
			final AnnotatedElement annotations = method;
			final EntityPropertyIndex entityPropertIndex = method.getAnnotation(EntityPropertyIndex.class);
			
			ctx.postponeTillExit(fieldName, () -> {
				driver.createProperty(type.value(), fieldName, fieldType, linkedType, order, annotations);
				if(entityPropertIndex!=null) 
					driver.createIndex(type.value(), 
									   defaultIfNullOrEmpty(entityPropertIndex.name(), type.value()+"."+fieldName),
									   Strings.emptyToNull(entityPropertIndex.type()), 
									   annotations, fieldName);
			});
			if(linkedType!=null && !wasPreviouslyScheduled) ctx.postponeTillDefined(linkedType, () -> {
				String inverse = property!=null?Strings.emptyToNull(property.inverse()):null;
				driver.setupRelationship(type.value(), fieldName, linkedType, inverse);
			});
		}
		
		driver.createType(type.value(), type.isAbstract(), clazz, superClasses.toArray(new String[superClasses.size()]));
		
		ctx.exiting(clazz, type.value());
		for (EntityIndex index : clazz.getAnnotationsByType(EntityIndex.class)) {
			driver.createIndex(type.value(), index.name(), index.type(), clazz, index.properties());
		}
		driver.onPostCreateType(type.value(), clazz);
		return type.value();
	}
	
	/*private static boolean canSkipIfAlreadyScheduled(EntityProperty entityProperty) {
		if(entityProperty==null) return true;
		Set<String> difference = CommonUtils.diffAnnotations(entityProperty, DEFAULT_DAOFIELD);
		return difference.size()==1 && difference.contains("value");
	}*/
	
	
	
	private <T> T setTransponder(T object) {
		return setTransponder(object, this);
	}
	
	private static <T> T setTransponder(T object, Transponder transponder) {
		if(!(object instanceof ITransponderHolder)) throw new IllegalArgumentException("Object has not been provided by Transponder");
		((ITransponderHolder)object).set$transponder(transponder);
		return object;
	}
	
	/**
	 * Extract {@link Transponder} from the provided wrapped entity to DAO
	 * @param object object to analyze and extract {@link Transponder} from
	 * @return {@link Transponder} for the provided object
	 */
	public static Transponder getTransponder(Object object) {
		if(!(object instanceof ITransponderHolder)) throw new IllegalArgumentException("Object has not been provided by Transponder");
		return ((ITransponderHolder)object).get$transponder();
	}
	
	/**
	 * @return {@link IPolyglot} for current {@link Transponder}
	 */
	public IPolyglot getPolyglot() {
		return polyglot;
	}
	
	/**
	 * Update polyglot
	 * @param polyglot new polyglot instance to set
	 */
	public void setPolyglot(IPolyglot polyglot) {
		if(polyglot==null) throw new IllegalArgumentException("Polyglot can't be null");
		this.polyglot = polyglot;
		DAO_CACHE.clear(); //We have to clear cache because all previous translations are cached in bytecode
	}
	
	/**
	 * Save/persist wrapped entity in the data-source
	 * @param object wrapped entity to be persisted
	 */
	public static void save(Object object) {
		Transponder transponder = getTransponder(object);
		transponder.getDriver().saveEntityInstance(object);
	}
	
	private static class DescribeContext {
		
		class ContextItem {
			private Class<?> typeClass;
			private String type;
			private Map<String, Runnable> postponedTillExit = new TreeMap<String, Runnable>((a, b) -> a.compareTo(b));
			private Multimap<String, Runnable> postponedTillDefined = ArrayListMultimap.create();
			
			ContextItem(Class<?> daoClass, String oClass) {
				this.typeClass = daoClass;
				this.type = oClass;
			}
		}
		
		private final Transponder transponder;
		
		private Map<Class<?>, String> describedClasses = new HashMap<Class<?>, String>();
		
		private Stack<Class<?>> processingStackIndex = new Stack<Class<?>>();
		private Stack<ContextItem> processingStack = new Stack<ContextItem>();
		
		private Multimap<String, Runnable> globalPostponedTillDefined = ArrayListMultimap.create();
		
		public DescribeContext(Transponder transponder) {
			this.transponder = transponder;
		}
		

		public void entering(Class<?> clazz, String type) {
			if(processingStackIndex.contains(clazz)) throw new IllegalStateException("Class "+clazz.getName()+" is already in stack. Stop infinite loop.");
			processingStackIndex.push(clazz);
			processingStack.push(new ContextItem(clazz, type));
		}
		
		public void exiting(Class<?> clazz, String type) {
			Class<?> exiting = processingStackIndex.pop();
			if(!clazz.equals(exiting)) throw new IllegalStateException("Exiting from wrong execution: expected "+clazz.getName()+" but in a stack "+exiting.getName());
			ContextItem last = processingStack.pop();
			if(!type.equals(last.type))  throw new IllegalStateException("Exiting from wrong execution: expected "+type+" but in a stack "+last.type);
			describedClasses.put(clazz, type);
			for (Runnable postponed : last.postponedTillExit.values()) {
				postponed.run();
			}
			
			Multimap<String, Runnable> mergeTo = processingStack.empty()?globalPostponedTillDefined:processingStack.lastElement().postponedTillDefined;
			Iterator<Map.Entry<String, Collection<Runnable>>> it = last.postponedTillDefined.asMap().entrySet().iterator();
			while(it.hasNext()) {
				Map.Entry<String, Collection<Runnable>> entry = it.next();
				if(wasDescribed(entry.getKey())) {
					for (Runnable runnable : entry.getValue()) {
						runnable.run();
					}
					it.remove();
				} else {
					Collection<Runnable> mergeToValue = mergeTo.get(entry.getKey());
					if(mergeToValue!=null) mergeToValue.addAll(entry.getValue());
					else mergeTo.putAll(entry.getKey(), entry.getValue());
				}
			}
			
		}
		
		public boolean inStack(Class<?> clazz) {
			return processingStackIndex.contains(clazz);
		}
		
		public boolean wasDescribed(Class<?> clazz) {
			return describedClasses.containsKey(clazz);
		}
		
		public boolean wasDescribed(String oClass) {
			return describedClasses.containsValue(oClass);
		}
		
		public String getDefinedType(Class<?> clazz) {
			return describedClasses.get(clazz);
		}
		
		public String getTypeFromStack(Class<?> clazz) {
			int indx = processingStackIndex.indexOf(clazz);
			return indx>=0?processingStack.get(indx).type:null;
		}
		
		public String resolveType(Class<?> clazz, Supplier<String> supplier) {
			String ret = getDefinedType(clazz);
			if(Strings.isNullOrEmpty(ret)) ret = getTypeFromStack(clazz);
			return !Strings.isNullOrEmpty(ret) ? ret : supplier.get();
		}
		
		public String resolveOrDefineTypeClass(Class<?> clazz, boolean lazyDefine) {
			if(clazz==null) return null;
			final EntityType type = clazz.getAnnotation(EntityType.class);
			if(type==null) return null;
			String ret = getDefinedType(clazz);
			if(Strings.isNullOrEmpty(ret)) ret = getTypeFromStack(clazz);
			if(Strings.isNullOrEmpty(ret)) {
				if(lazyDefine) {
					ret = type.value();
					//Char '~' is needed to be the very last in queue
					postponeTillExit("~create:"+ret, () -> transponder.define(clazz, this));
				} else {
					ret = transponder.define(clazz, this);
				}
			}
			return ret;
		}
		
		public boolean isPropertyCreationScheduled(String propertyName) {
			return processingStack.lastElement().postponedTillExit.containsKey(propertyName);
		}
		
		public void postponeTillExit(String propertyName, Runnable supplier) {
			processingStack.lastElement().postponedTillExit.put(propertyName, supplier);
		}
		
		public void postponeTillDefined(String linkedClass, Runnable supplier) {
			processingStack.lastElement().postponedTillDefined.put(linkedClass, supplier);
		}
		
		public void close(boolean restrictDependencies) {
			if(processingStackIndex.size()>0) throw new IllegalStateException("Can't close context because stack is not null");
			Collection<Runnable> remaining = globalPostponedTillDefined.values();
			if(restrictDependencies && remaining.size()>0) throw new IllegalStateException("There are unsitisfied dependencies");
			remaining.forEach(Runnable::run);
		}
		
		public String getCurrentType() {
			return processingStack.peek().type;
		}

	}
	
}
